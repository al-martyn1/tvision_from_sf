/* X11 screen routines.
   Copyright (c) 2001-2002 by Salvador E. Tropea (SET)
   Covered by the GPL license.
    Thanks to José Ángel Sánchez Caso (JASC). He implemented a first X11
   driver.
    This implementation is completly different but JASC's code gave me the
   first notions about how an X11 application works.

   ToDo:
   * The SetDisPaletteColors does a redraw, it should be avoided, at least
   for 8 bpp modes, BTW they are untested.
*/

#include <tv/configtv.h>

// That's a nasty side effect: X defines Boolean!
#if defined(TVOS_UNIX) && defined(HAVE_X11)
 #include <X11/Xmu/Atoms.h>
#endif

#define Uses_stdio
#define Uses_stdlib
#define Uses_string
#define Uses_unistd   // TScreenX11::System
#define Uses_TDisplay
#define Uses_TScreen
#define Uses_TGKey    // For TGKeyX11
#define Uses_TEvent   // For THWMouseX11
#define Uses_TVCodePage
#define Uses_TVOSClipboard
#include <tv.h>

// I delay the check to generate as much dependencies as possible
#if defined(TVOS_UNIX) && defined(HAVE_X11)

// X11 defines their own values
#undef True
#undef False
#define True  1
#define False 0

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <X11/Xatom.h>

#include <tv/x11/screen.h>
#include <tv/x11/key.h>
#include <tv/x11/mouse.h>

#include <locale.h>
#include <signal.h>
#include <sys/time.h>

#ifdef TVOSf_Solaris
 // At least in the Solaris 7 box I tested looks like ITIMER_REAL is broken
 // and behaves like ITIMER_VIRTUAL
 #define ITIMER_USED ITIMER_REALPROF
 #define TIMER_ALARM SIGPROF
#else
 #define ITIMER_USED ITIMER_REAL
 #define TIMER_ALARM SIGALRM
#endif


const int cursorDelay=300000;

/*****************************************************************************

  TScreenX11 screen stuff.

*****************************************************************************/

Display  *TScreenX11::disp;
ulong     TScreenX11::screen;
Visual   *TScreenX11::visual;
Window    TScreenX11::rootWin;
Window    TScreenX11::mainWin;
Colormap  TScreenX11::cMap;
GC        TScreenX11::gc;
GC        TScreenX11::cursorGC;
XIC       TScreenX11::xic;
XIM       TScreenX11::xim;
Atom      TScreenX11::theProtocols;
ulong     TScreenX11::colorMap[16];
XImage   *TScreenX11::ximgFont[256];    /* Our "font" is just a collection of images */
XImage   *TScreenX11::ximgSecFont[256];
XImage   *TScreenX11::cursorImage;
int       TScreenX11::fg;
int       TScreenX11::bg;
char      TScreenX11::cursorEnabled=1;
char      TScreenX11::cursorInScreen=0;
uchar     TScreenX11::curAttr;
char     *TScreenX11::cursorData;
volatile
char      TScreenX11::cursorChange=0;
XSizeHints *TScreenX11::sizeHints=NULL;
XClassHint *TScreenX11::classHint=NULL;


TScreenX11::~TScreenX11() {}

void TScreenX11::clearScreen()
{
 XSetForeground(disp,gc,colorMap[bg]);
 XFillRectangle(disp,mainWin,gc,0,0,maxX*fontW,maxY*fontH);
 XSetForeground(disp,gc,colorMap[fg]);

 char space[2];
 space[charPos]=' ';
 space[attrPos]=curAttr;

 unsigned c=maxX*maxY;
 while (c--)
   screenBuffer[c]=*((ushort *)space);
}

inline
void TScreenX11::drawChar(GC gc, unsigned x, unsigned y, uchar aChar, uchar aAttr)
{
 if (useSecondaryFont && (aAttr & 0x8))
    XPutImage(disp,mainWin,gc,ximgSecFont[aChar],0,0,x,y,fontW,fontH);
 else
    XPutImage(disp,mainWin,gc,ximgFont[aChar],0,0,x,y,fontW,fontH);
}

void TScreenX11::setCharacter(unsigned offset, ushort value)
{
 screenBuffer[offset]=value;

 unsigned x,y;
 x=(offset%maxX)*fontW;
 y=(offset/maxX)*fontH;

 uchar *theChar=(uchar *)(screenBuffer+offset);
 uchar newChar=theChar[charPos];
 uchar newAttr=theChar[attrPos];
 XSetBackground(disp,gc,colorMap[newAttr>>4]);
 XSetForeground(disp,gc,colorMap[newAttr&0xF]);
 UnDrawCursor();
 drawChar(gc,x,y,newChar,newAttr);
 DrawCursor();
 XFlush(disp);
}

void TScreenX11::setCharacters(unsigned offset, ushort *values, unsigned count)
{
 unsigned x,y;
 x=(offset%maxX)*fontW;
 y=(offset/maxX)*fontH;

 uchar *b=(uchar *)values,newChar,newAttr;
 uchar *sb=(uchar *)(screenBuffer+offset);
 unsigned oldAttr=0x100;
 UnDrawCursor();
 while (count--)
   {
    newChar=b[charPos];
    newAttr=b[attrPos];
    if (newChar!=sb[charPos] || newAttr!=sb[attrPos])
      {
       sb[charPos]=newChar;
       sb[attrPos]=newAttr;
       if (newAttr!=oldAttr)
         {
          XSetBackground(disp,gc,colorMap[newAttr>>4]);
          XSetForeground(disp,gc,colorMap[newAttr&0xF]);
          oldAttr=newAttr;
         }
       drawChar(gc,x,y,newChar,newAttr);
      }
    x+=fontW; b+=2; sb+=2;
   }
 DrawCursor();
 XFlush(disp);
}

int TScreenX11::System(const char *command, pid_t *pidChild)
{
 if (!pidChild)
    return system(command);

 pid_t cpid=fork();
 if (cpid==0)
   {// Ok, we are the child
    //   I'm not sure about it, but is the best I have right now.
    //   Doing it we can kill this child and all the subprocesses
    // it creates by killing the group. It also have an interesting
    // effect that I must evaluate: By doing it this process lose
    // the controlling terminal and won't be able to read/write
    // to the parents console. I think that's good.
    if (setsid()==-1)
       _exit(127);
    char *argv[4];
   
    argv[0]=getenv("SHELL");
    if (!argv[0])
       argv[0]="/bin/sh";
    argv[1]="-c";
    argv[2]=(char *)command;
    argv[3]=0;
    execvp(argv[0],argv);
    // We get here only if exec failed
    _exit(127);
   }
 if (cpid==-1)
   {// Fork failed do it manually
    *pidChild=0;
    return system(command);
   }
 *pidChild=cpid;
 return 0;
}

static uchar DefaultFont[]=
{
 0x00,0x00,0x7E,0xC3,0x99,0x99,0xF3,0xE7,0xE7,0xFF,0xE7,0xE7,0x7E,0x00,0x00,0x00, // 0
 0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x6E,0xF8,0xD8,0xD8,0xDC,0xD8,0xD8,0xD8,0xF8,0x6E,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x6E,0xDB,0xDB,0xDF,0xD8,0xDB,0x6E,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x88,0x88,0xF8,0x88,0x88,0x00,0x3E,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00, // 
 0x00,0xF8,0x80,0xE0,0x80,0x80,0x00,0x3E,0x20,0x38,0x20,0x20,0x00,0x00,0x00,0x00, // 
 0x00,0x70,0x88,0x80,0x88,0x70,0x00,0x3C,0x22,0x3C,0x24,0x22,0x00,0x00,0x00,0x00, // 
 0x00,0x80,0x80,0x80,0x80,0xF8,0x00,0x3E,0x20,0x38,0x20,0x20,0x00,0x00,0x00,0x00, // 
 0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44, // \t
 0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA, // \n
 0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77, // 
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // \r
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, // 
 0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F, // 
 0x00,0x88,0xC8,0xA8,0x98,0x88,0x00,0x20,0x20,0x20,0x20,0x3E,0x00,0x00,0x00,0x00, // 
 0x00,0x88,0x88,0x50,0x50,0x20,0x00,0x3E,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x0E,0x38,0xE0,0x38,0x0E,0x00,0xFE,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0xE0,0x38,0x0E,0x38,0xE0,0x00,0xFE,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x06,0x0C,0xFE,0x18,0x30,0xFE,0x60,0xC0,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x06,0x1E,0x7E,0xFE,0x7E,0x1E,0x06,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0xC0,0xF0,0xFC,0xFE,0xFC,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00, // 0x1A
 0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x28,0x6C,0xFE,0x6C,0x28,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x06,0x36,0x66,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //  
 0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // !
 0x00,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "
 0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00, // #
 0x00,0x10,0x10,0x7C,0xD6,0xD0,0xD0,0x7C,0x16,0x16,0xD6,0x7C,0x10,0x10,0x00,0x00, // $
 0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00, // %
 0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // &
 0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
 0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00, // (
 0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00, // )
 0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00, // *
 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00, // +
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00, // ,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // -
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // .
 0x00,0x00,0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0xC0,0x00,0x00,0x00,0x00,0x00, // /
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xD6,0xD6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // 0
 0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00, // 1
 0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00, // 2
 0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00, // 3
 0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, // 4
 0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00, // 5
 0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // 6
 0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00, // 7
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // 8
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00, // 9
 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00, // :
 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00, // ;
 0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00, // <
 0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // =
 0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00, // >
 0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // ?
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00, // @
 0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // A
 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00, // B
 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00, // C
 0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00, // D
 0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00, // E
 0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, // F
 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00, // G
 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // H
 0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // I
 0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00, // J
 0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, // K
 0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00, // L
 0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // M
 0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // N
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // O
 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, // P
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00, // Q
 0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, // R
 0x00,0x00,0x7C,0xC6,0xC6,0x64,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // S
 0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // T
 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // U
 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00, // V
 0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00, // W
 0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00, // X
 0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Y
 0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00, // Z
 0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00, // [
 0x00,0x00,0x00,0x00,0x00,0xC0,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,0x00, // \ .
 0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00, // ]
 0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ^
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00, // _
 0x00,0x30,0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // `
 0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // a
 0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00, // b
 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // c
 0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // d
 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // e
 0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, // f
 0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00, // g
 0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, // h
 0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // i
 0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00, // j
 0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00, // k
 0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // l
 0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00, // m
 0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00, // n
 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // o
 0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00, // p
 0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00, // q
 0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, // r
 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00, // s
 0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00, // t
 0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // u
 0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00, // v
 0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00, // w
 0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00, // x
 0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00, // y
 0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00, // z
 0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00, // {
 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // |
 0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00, // }
 0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ~
 0x00,0x66,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x60,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6F,0x60,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x60,0x6F,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6F,0x60,0x6F,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0C,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0xEC,0x0C,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0xEF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x0C,0xEC,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0xEC,0x0C,0xEC,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xEF,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0xEF,0x00,0xEF,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C, // 
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0xFE,0x00,0x00,0x00,0x00, //  
 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3C,0x3C,0x3C,0x18,0x00,0x00, // ¡
 0x00,0x00,0x00,0x00,0x10,0x7C,0xD6,0xD0,0xD0,0xD0,0xD6,0x7C,0x10,0x00,0x00,0x00, // ¢
 0x00,0x00,0x38,0x6C,0x60,0x60,0xF0,0x60,0x60,0x66,0xF6,0x6C,0x00,0x00,0x00,0x00, // £
 0x00,0x00,0x00,0x00,0xC6,0x7C,0x6C,0x6C,0x7C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00, // ¤
 0x00,0x00,0x66,0x66,0x3C,0x18,0x7E,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // ¥
 0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // ¦
 0x00,0x7C,0xC6,0x60,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00, // §
 0x00,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ¨
 0x00,0x00,0x3C,0x42,0x99,0xA5,0xA1,0xA5,0x99,0x42,0x3C,0x00,0x00,0x00,0x00,0x00, // ©
 0x00,0x00,0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ª
 0x00,0x00,0x00,0x00,0x00,0x36,0x6C,0xD8,0x6C,0x36,0x00,0x00,0x00,0x00,0x00,0x00, // «
 0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00, // ¬
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ­
 0x00,0x00,0x3C,0x42,0xB9,0xA5,0xB9,0xA5,0xA5,0x42,0x3C,0x00,0x00,0x00,0x00,0x00, // ®
 0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ¯
 0x00,0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // °
 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x7E,0x00,0x00,0x00,0x00, // ±
 0x38,0x6C,0x18,0x30,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ²
 0x38,0x6C,0x18,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ³
 0x00,0x18,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ´
 0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xF6,0xC0,0xC0,0xC0,0x00, // µ
 0x00,0x00,0x7F,0xD6,0xD6,0x76,0x36,0x36,0x36,0x36,0x36,0x36,0x00,0x00,0x00,0x00, // ¶
 0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ·
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x6C,0x38,0x00, // ¸
 0x30,0x70,0x30,0x30,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ¹
 0x00,0x00,0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // º
 0x00,0x00,0x00,0x00,0x00,0xD8,0x6C,0x36,0x6C,0xD8,0x00,0x00,0x00,0x00,0x00,0x00, // »
 0x00,0x60,0xE0,0x60,0x66,0x0C,0x18,0x30,0x66,0xCE,0x1A,0x3F,0x06,0x06,0x00,0x00, // ¼
 0x00,0x60,0xE0,0x60,0x66,0x0C,0x18,0x30,0x6E,0xDB,0x06,0x0C,0x1F,0x00,0x00,0x00, // ½
 0x70,0xD8,0x30,0xD8,0x76,0x0C,0x18,0x30,0x66,0xCE,0x1A,0x3F,0x06,0x06,0x00,0x00, // ¾
 0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x30,0x60,0xC6,0xC6,0x7C,0x00,0x00, // ¿
 0x60,0x30,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // À
 0x0C,0x18,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Á
 0x10,0x38,0x6C,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Â
 0x76,0xDC,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Ã
 0x00,0x6C,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Ä
 0x38,0x6C,0x38,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Å
 0x00,0x00,0x3E,0x78,0xD8,0xD8,0xFC,0xD8,0xD8,0xD8,0xD8,0xDE,0x00,0x00,0x00,0x00, // Æ
 0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x0C,0x66,0x3C,0x00, // Ç
 0x60,0x30,0x00,0xFE,0x66,0x60,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00, // È
 0x0C,0x18,0x00,0xFE,0x66,0x60,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00, // É
 0x10,0x38,0x6C,0x00,0xFE,0x66,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00, // Ê
 0x00,0x6C,0x00,0xFE,0x66,0x60,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00, // Ë
 0x60,0x30,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Ì
 0x06,0x0C,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Í
 0x18,0x3C,0x66,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Î
 0x00,0x66,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Ï
 0x00,0x00,0xF8,0x6C,0x66,0x66,0xF6,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00, // Ð
 0x76,0xDC,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, // Ñ
 0x60,0x30,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ò
 0x0C,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ó
 0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ô
 0x76,0xDC,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Õ
 0x00,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ö
 0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00, // ×
 0x00,0x00,0x7E,0xC6,0xCE,0xCE,0xDE,0xF6,0xE6,0xE6,0xC6,0xFC,0x00,0x00,0x00,0x00, // Ø
 0x60,0x30,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ù
 0x0C,0x18,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ú
 0x10,0x38,0x6C,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Û
 0x00,0x6C,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // Ü
 0x06,0x0C,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Ý
 0x00,0x00,0xF0,0x60,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0xF0,0x00,0x00,0x00,0x00, // Þ
 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xCC,0xC6,0xC6,0xC6,0xD6,0xDC,0x80,0x00,0x00,0x00, // ß
 0x00,0x60,0x30,0x18,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // à
 0x00,0x18,0x30,0x60,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // á
 0x00,0x10,0x38,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // â
 0x00,0x00,0x76,0xDC,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // ã
 0x00,0x00,0x00,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // ä
 0x00,0x38,0x6C,0x38,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // å
 0x00,0x00,0x00,0x00,0x00,0x7E,0xDB,0x1B,0x7F,0xD8,0xDB,0x7E,0x00,0x00,0x00,0x00, // æ
 0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x18,0x6C,0x38,0x00, // ç
 0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // è
 0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // é
 0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // ê
 0x00,0x00,0x00,0x6C,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, // ë
 0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // ì
 0x00,0x0C,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // í
 0x00,0x18,0x3C,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // î
 0x00,0x00,0x00,0x6C,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // ï
 0x00,0x78,0x30,0x78,0x0C,0x7E,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // ð
 0x00,0x00,0x76,0xDC,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00, // ñ
 0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // ò
 0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // ó
 0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // ô
 0x00,0x00,0x76,0xDC,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // õ
 0x00,0x00,0x00,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, // ö
 0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x7E,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00, // ÷
 0x00,0x00,0x00,0x00,0x00,0x7E,0xCE,0xDE,0xFE,0xF6,0xE6,0xFC,0x00,0x00,0x00,0x00, // ø
 0x00,0x60,0x30,0x18,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // ù
 0x00,0x18,0x30,0x60,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // ú
 0x00,0x30,0x78,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // û
 0x00,0x00,0x00,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, // ü
 0x00,0x0C,0x18,0x30,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00, // ý
 0x00,0x00,0xF0,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00,0x00, // þ
 0x00,0x00,0x00,0x6C,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00  // 255
};

static
void microAlarm(unsigned int usec)
{
 struct itimerval newV;
 newV.it_interval.tv_usec=0;
 newV.it_interval.tv_sec=0;
 newV.it_value.tv_usec=(long int)usec;
 newV.it_value.tv_sec=0;
 setitimer(ITIMER_USED,&newV,0);
}

TScreenX11::TScreenX11()
{
 int col;

 maxX=80; maxY=25;
 fontW=8; fontH=16;

 /* Try to connect to the X server */
 disp=XOpenDisplay("");
 /* If we fail just return */
 if (!disp)
    return;
 /* Allocate memory for these structures. Note that is safer to do it instead
    of using a static structure because the number of fields can change. */
 sizeHints=XAllocSizeHints();
 classHint=XAllocClassHint();
 if (!sizeHints || !classHint)
    return;

 /* Don't need special rights anymore */
 seteuid(getuid());
 setegid(getgid());
 
 /* Initialize driver */
 initialized=1;

 TDisplayX11::Init();

 TScreen::clearScreen=clearScreen;
 TScreen::getCharacters=getCharacters;
 TScreen::getCharacter=getCharacter;
 TScreen::setCharacter=setCharacter;
 TScreen::setCharacters=setCharacters;
 TScreen::System=System;
 TScreen::setWindowTitle=setWindowTitle;
 TScreen::getWindowTitle=getWindowTitle;
 TScreen::setDisPaletteColors=SetDisPaletteColors;
 TScreen::getFontGeometry=GetFontGeometry;
 TScreen::getFontGeometryRange=GetFontGeometryRange;
 TScreen::setFont=SetFont;
 TScreen::restoreFonts=RestoreFonts;

 TVX11Clipboard::Init();
 TGKeyX11::Init();
 THWMouseX11::Init();

 /* Initialize common variables */
 cShapeFrom=14;
 cShapeTo=16;
 setCrtData();
 startupCursor=cursorLines;
 startupMode=screenMode;
 screenBuffer=new ushort[screenWidth*screenHeight];

 /* Get screen and graphic context */
 screen=DefaultScreen(disp);
 gc=DefaultGC(disp,screen);
 visual=DefaultVisual(disp,screen);

 /* Create what we'll use as font */
 CreateXImageFont(0,DefaultFont,fontW,fontH);
 /* Set up the code page used for it */
 codePage=new TVCodePage(TVCodePage::ISOLatin1Linux,TVCodePage::ISOLatin1Linux);

 /* Create the cursor image */
 cursorData=(char *)malloc(fontH);
 cursorImage=XCreateImage(disp,visual,1,XYBitmap,0,cursorData,fontW,fontH,8,0);
 cursorImage->byte_order=cursorImage->bitmap_bit_order=MSBFirst;

 /* Set the locales */
 if (setlocale(LC_ALL,"")==NULL)
    fprintf(stderr,"Error: setlocale()!\n");

 /* Create a simple window */
 rootWin=RootWindow(disp,screen);
 mainWin=XCreateSimpleWindow(disp,rootWin,
         0,0,                             /* win position */
         maxX*fontW,maxY*fontH,           /* win size */
         0,                               /* frame width */
         BlackPixel(disp,screen),   /* Border color */
         BlackPixel(disp,screen));  /* Background */

 /* This is useful if we use subwindows.
 hints.flags=InputHint;
 hints.input=True;
 XSetWMHints(disp,mainWin,&hints);*/
 /* This is how we provide a title for the window.
    If the application wants it should call setWindowTitle.
 XTextProperty name;
 char *s="Test";
 XStringListToTextProperty(&s,1,&name);*/

 classHint->res_name="tvapp";   /* Take resources for tvapp */
 classHint->res_class="XTVApp"; /* X Turbo Vision Application */

 sizeHints->flags=PResizeInc /* These are useless: |PBaseSize|PMinSize */;
 /* Fonts increments */
 sizeHints->width_inc =fontW;
 sizeHints->height_inc=fontH;

 XSetWMProperties(disp,mainWin,
                  NULL,       /* Visible title, i.e. &name */
                  NULL,       /* Icon title, i.e. &name */
                  NULL,0,     /* Command line */
                  sizeHints,  /* Normal size hints, resize increments */
                  NULL,       /* Window manager hints, nothing (i.e. icon) */
                  classHint); /* Resource name and class of window */

 /* This is needed to release the memory used for the title
 XFree((char *)name.value);*/

 /* Ask to be notified when they kill the window */
 theProtocols=XInternAtom(disp,"WM_DELETE_WINDOW",True);
 XSetWMProtocols(disp,mainWin,&theProtocols,1);

 /* Initialize the Input Context for international support */
 if ((xim=XOpenIM(disp,NULL,NULL,NULL))==NULL)
   {
    printf("Error: XOpenIM()!\n");
    exit(0);
   }
 xic=XCreateIC(xim,XNInputStyle,XIMPreeditNothing | XIMStatusNothing,
               XNClientWindow,mainWin,NULL);
 if (xic==NULL)
   {
    printf("Error: XCreateIC()!\n");
    XCloseIM(xim);
    exit(0);
   }

 /* We will accept the Input Context default events ... */
 unsigned long mask, fevent;
 XGetICValues(xic,XNFilterEvents,&fevent,NULL);
 /* plus these */
 mask=ExposureMask | KeyPressMask | KeyReleaseMask | FocusChangeMask |
      StructureNotifyMask | ButtonPressMask | ButtonReleaseMask |
      ButtonMotionMask/*PointerMotionMask*/;
 XSelectInput(disp,mainWin,mask|fevent);

 /* OK, now put the window on the display */
 XMapWindow(disp,mainWin);

 /* Map the VGA Text BIOS colors */
 cMap=DefaultColormap(disp,screen);
 XColor query;
 for (col=0; col<16; col++)
    {
     query.red  =PC_BIOSPalette[col].R*256;
     query.green=PC_BIOSPalette[col].G*256;
     query.blue =PC_BIOSPalette[col].B*256;
     query.flags= ~0;
     XAllocColor(disp,cMap,&query);
     colorMap[col]=query.pixel;
    }
 memcpy(ActualPalette,PC_BIOSPalette,sizeof(ActualPalette));

 /* A graphics context for the text cursor */
 cursorGC=XCreateGC(disp,mainWin,0,0);

 /* Create the cursor timer */
 struct sigaction action;
 action.sa_handler=sigAlm;
 sigemptyset(&action.sa_mask);
 action.sa_flags=0;
 sigaction(TIMER_ALARM,&action,NULL);
 //signal(SIGALRM,sigAlm); To avoid SVID vs BSD differences
 microAlarm(cursorDelay);

 XSetBackground(disp,gc,colorMap[0]);
 XSetForeground(disp,gc,colorMap[7]);
 clearScreen();

 // Setup the driver properties.
 // Our code page isn't fixed.
 // We can change the palette.
 // A redraw is needed after setting the palette. But currently is in the color setting.
 // We can set the fonts and even change their size.
 flags0=CanSetPalette | CanReadPalette | CodePageVar | CursorShapes /*| PalNeedsRedraw*/ |
        CanSetBFont | CanSetSBFont | CanSetFontSize;
}

void TScreenX11::CreateXImageFont(int which, uchar *font, unsigned w, unsigned h)
{
 char *data;
 int i;
 XImage **f=which ? ximgSecFont : ximgFont;
 for (i=0; i<256; i++)
    {/* Load the shape */
     data=(char *)malloc(h);
     memcpy(data,font+i*h,h);
     /* Create a BitMap Image with this data */
     f[i]=XCreateImage(disp,visual,1,XYBitmap,0,data,w,h,8,0);
     /* Set the bit order */
     f[i]->byte_order=f[i]->bitmap_bit_order=MSBFirst;
    }
 if (which)
    useSecondaryFont=1;
}

void TScreenX11::DestroyXImageFont(int which)
{
 int i;

 if (which)
   {
    if (useSecondaryFont)
      {
       for (i=0; i<256; i++)
           XDestroyImage(ximgSecFont[i]);
       useSecondaryFont=0;
      }
   }
 else
   for (i=0; i<256; i++)
       XDestroyImage(ximgFont[i]);
}

int TScreenX11::setWindowTitle(const char *aName)
{
 XTextProperty name;
 char *s=(char *)aName;
 XStringListToTextProperty(&s,1,&name);
 XSetWMName(disp,mainWin,&name);
 XFree((char *)name.value);
 
 return 1;
}

const char *TScreenX11::getWindowTitle(void)
{
 XTextProperty name;
 if (XGetWMName(disp,mainWin,&name))
   {
    char *s=newStr((char *)name.value);
    XFree((char *)name.value);
    return s;
   }
 return 0;
}

int TScreenX11::SetDisPaletteColors(int from, int number, TScreenColor *colors)
{
 XColor query;
 int i;
 ulong newMap[16];

 for (i=0; i<number; i++)
    {
     query.red  =colors[i].R*256;
     query.green=colors[i].G*256;
     query.blue =colors[i].B*256;
     query.flags= ~0;
     if (!XAllocColor(disp,cMap,&query))
        break;
     newMap[i]=query.pixel;
    }
 if (i>0)
   {// If we allocated at least one color:
    // Deallocated the old colors
    XFreeColors(disp,cMap,colorMap+from,i,0);
    // Copy the new ones
    memcpy(colorMap+from,newMap,sizeof(ulong)*i);
    // Force a redraw. This is not needed for 8 bpp.
    // Is just a dirty hack.
    FullRedraw();
   }
 return i;
}

void TScreenX11::FullRedraw()
{
 unsigned y,off;
 for (y=0,off=0; y<(unsigned)maxY; y++,off+=maxX)
     redrawBuf(0,y,maxX,off);
}

/*****************************************************************************
 Routines to create a blinking cursor
*****************************************************************************/

void TScreenX11::sigAlm(int sig)
{
 cursorChange=1;
 microAlarm(cursorDelay);
}

void TScreenX11::UnDrawCursor()
{
 if (!cursorInScreen)
    return;
 unsigned offset=cursorX+cursorY*maxX;
 uchar *theChar=(uchar *)(screenBuffer+offset);
 uchar newChar=theChar[charPos];
 uchar newAttr=theChar[attrPos];
 int bg=newAttr>>4;
 int fg=newAttr & 0xF;

 XSetBackground(disp,cursorGC,colorMap[bg]);
 XSetForeground(disp,cursorGC,colorMap[fg]);
 drawChar(cursorGC,cursorX*fontW,cursorY*fontH,newChar,newAttr);
 cursorInScreen=0;
 return;
}

void TScreenX11::DrawCursor()
{
 //fprintf(stderr,"DrawCursor: cursorEnabled=%d\n",cursorEnabled);
 if (cursorEnabled)
   {
    cursorInScreen=!cursorInScreen;

    /* Create an image with the character under cursor */
    unsigned offset=cursorX+cursorY*maxX;
    uchar *theChar=(uchar *)(screenBuffer+offset);
    int bg=theChar[attrPos]>>4;
    int fg=theChar[attrPos] & 0xF;
    XSetBackground(disp,cursorGC,colorMap[bg]);
    XSetForeground(disp,cursorGC,colorMap[fg]);
    memcpy(cursorData,ximgFont[theChar[charPos]]->data,fontH);

    //fprintf(stderr,"DrawCursor: cursorInScreen=%d from/to %d/%d\n",cursorInScreen,cShapeFrom,cShapeTo);
    /* If the cursor is on draw it over the character */
    if (cursorInScreen)
       memset(cursorData+cShapeFrom,0xFF,cShapeTo-cShapeFrom);

    /* Now put it in the screen */
    XPutImage(disp,mainWin,cursorGC,cursorImage,0,0,cursorPX,cursorPY,fontW,fontH);
    XFlush(disp);
   }
}

void TScreenX11::DisableCursor()
{
 cursorEnabled=0;
 UnDrawCursor();
}

void TScreenX11::EnableCursor()
{
 cursorEnabled=1;
 //DrawCursor();
}

/*****************************************************************************
 Events processing
*****************************************************************************/

void TScreenX11::ProcessGenericEvents()
{
 XEvent event;
 unsigned lastW, lastH;
 unsigned newPW, newPH;

 while (1)
   {
    if (cursorChange)
      {
       cursorChange=0;
       DrawCursor();
      }
    /* Check if we have generic events in the queue */
    if (XCheckMaskEvent(disp,~(aMouseEvent|aKeyEvent),&event)!=True)
      {
       /* Process message that doesn't have mask */
       if (XCheckTypedEvent(disp,ClientMessage,&event)==True)
         {
          if ((Atom)event.xclient.data.l[0]==theProtocols)
            {
             /*printf("Bye, bye!\n");
             XDestroyIC(xic);
             XCloseIM(xim);
             XDestroyWindow(disp,mainWin);
             XCloseDisplay(disp);
             exit(0);*/
             TGKeyX11::sendQuit=1;
            }
         }
       else if (XCheckTypedEvent(disp,SelectionRequest,&event)==True)
         {// Another application wants the content of our clipboard
          XEvent respond;
          XSelectionRequestEvent *req=&(event.xselectionrequest);
          if (req->target==XA_STRING && TVX11Clipboard::buffer)
            {
             XChangeProperty(disp,req->requestor,req->property,XA_STRING,
                             8/*bits*/,PropModeReplace,
                             (const uchar *)TVX11Clipboard::buffer,
                             TVX11Clipboard::length);
             respond.xselection.property=req->property;
            }
          else // Strings only please
             respond.xselection.property= None;
          respond.xselection.type=SelectionNotify;
          respond.xselection.display=req->display;
          respond.xselection.requestor=req->requestor;
          respond.xselection.selection=req->selection;
          respond.xselection.target=req->target;
          respond.xselection.time=req->time;
          XSendEvent(disp,req->requestor,0,0,&respond);
          XFlush(disp);
         }
       else if (XCheckTypedEvent(disp,SelectionNotify,&event)==True)
         {
          TVX11Clipboard::waiting=0;
          TVX11Clipboard::property=event.xselection.property;
         }
       return;
      }
    /* Not sure if needed, but documentation says it helps if the event
       should be redirected to another window */
    if (XFilterEvent(&event,0)==True)
       continue;
  
    switch (event.type)
      {
       case Expose:
            {
             /*printf("Expose: %d %d %d %d\n",event.xexpose.x,event.xexpose.y,
                    event.xexpose.width,event.xexpose.height);*/
             int x=event.xexpose.x/fontW;
             int y=event.xexpose.y/fontH;
             unsigned src=y*maxX+x;

             newPW=event.xexpose.x+event.xexpose.width;
             int x2=newPW/fontW;
             if (newPW%fontW) x2++;
             if (x2>=maxX) x2=maxX;

             newPW=event.xexpose.y+event.xexpose.height;
             int y2=newPW/fontH;
             if (newPW%fontH) y2++;
             if (y2>=maxY) y2=maxY;

             int w=x2-x;
             int h=y2-y;

             /*printf("x1,y1 %d,%d x2,y2 %d,%d w,h %d,%d\n",x,y,x2,y2,w,h);*/

             while (h)
               {
                redrawBuf(x,y,w,src);
                src+=maxX;
                y++; h--;
               }
             XFlush(disp);
            }
            break;

       case FocusIn:
            //printf("Focus in\n");
            if (xic)
               XSetICFocus(xic);
            break;

       case FocusOut:
            //printf("Focus out\n");
            if (xic)
               XUnsetICFocus(xic);
            break;

       case ConfigureNotify:
            if (event.xresizerequest.window!=mainWin)
               break;
    
            lastW=maxX;
            lastH=maxY;
            maxX=event.xconfigure.width /fontW;
            maxY=event.xconfigure.height/fontH;

            /* Minimal size */
            if (maxX<40) maxX=40;
            if (maxY<20) maxY=20;

            /* If size changed realloc buffer and indicate it */
            if ((maxX!=(int)lastW) || (maxY!=(int)lastH))
              {
               screenBuffer=(uint16 *)realloc(screenBuffer,maxX*maxY*2);
               windowSizeChanged=1;
              }

            /* Force the window to have a size in chars */
            newPW=fontW*maxX;
            newPH=fontH*maxY;

            if ((unsigned)event.xconfigure.width==newPW &&
                (unsigned)event.xconfigure.height==newPH)
               break;

            /*printf("Nuevo: %d,%d (%d,%d)\n",maxX,maxY,lastW,lastH);*/
            XResizeWindow(disp,mainWin,newPW,newPH);
            /*printf("Nuevo 2: %d,%d\n",maxX,maxY);*/
            break;
      }
   }
}

void TScreenX11::writeLine(int x, int y, int w, unsigned char *str, unsigned color)
{
 if (w<=0)
    return; // Nothing to do

 XSetBackground(disp,gc,colorMap[color>>4]);
 XSetForeground(disp,gc,colorMap[color&15]);

 x*=fontW; y*=fontH;
 UnDrawCursor();
 XImage **f=(useSecondaryFont && (color & 8)) ? ximgSecFont : ximgFont;
 while (w--)
   {
    XPutImage(disp,mainWin,gc,f[*str],0,0,x,y,fontW,fontH);
    str++;
    x+=fontW;
   }
}

void TScreenX11::redrawBuf(int x, int y, unsigned w, unsigned off)
{
 int len   = 0;         /* longitud a escribir */
 int letra = 0;
 int color = 0;
 int last  = -1;
 unsigned char *tmp = (unsigned char *)alloca(w*sizeof(char));
 unsigned char *dst = tmp;
 uchar *b=(uchar *)(screenBuffer+off);

 if (y>=maxY)
   {
    printf("Y=%d\n",y);
    return;
   }
 while (w--)
   {
    letra=b[charPos];
    color=b[attrPos];
    
    if (color!=last)
      {
       if (last>=0)
         {
          writeLine(x,y,len,tmp,last);  // Print last same color block
          dst=tmp; x+=len; len=0;
         }
       last=color;
      }
    *dst++=letra; b+=2; len++;
   }
  
 writeLine(x,y,len,tmp,color);          // Print last block
}

TScreen *TV_XDriverCheck()
{
 TScreenX11 *drv=new TScreenX11();
 if (!TScreen::initialized)
   {
    delete drv;
    return 0;
   }
 return drv;
}

/*****************************************************************************
  X11 clipboard routines
  This clipboard implementation is heavily based on the
  X Windows Copy-Paste mini HOWTO by Stelios Xathakis, <axanth@tee.gr>
*****************************************************************************/

char *TVX11Clipboard::buffer=NULL;
unsigned TVX11Clipboard::length=0;
int      TVX11Clipboard::waiting=0;
Atom     TVX11Clipboard::property=0;

const char *TVX11Clipboard::x11NameError[]=
{
 NULL,
 __("No available selection"),
 __("Unsupported data type"),
 __("No data"),
 __("X11 error"),
 __("Another application holds the clipboard")
};

void TVX11Clipboard::Init()
{
 TVOSClipboard::copy=copy;
 TVOSClipboard::paste=paste;
 TVOSClipboard::destroy=destroy;
 TVOSClipboard::available=2; // We have 2 clipboards
 TVOSClipboard::name="X11";
 TVOSClipboard::errors=x11clipErrors;
 TVOSClipboard::nameErrors=x11NameError;
}

/**[txh]********************************************************************

  Description:
  Copies the content of the buffer to the X11 clipboard. The id value
selects which clipboard we will use. As current recommendations says
applications should use XA_CLIPBOARD that's id==0. For id==1 we use the
XA_PRIMARY mechanism, this is the one used for "selections".@*
  The string doesn't have to be null terminated, we ever copy len+1 bytes
adding a 0 at the end.

  Return: !=0 if ok.
  
***************************************************************************/

int TVX11Clipboard::copy(int id, const char *b, unsigned len)
{
 if (id>1) return 0;
 Atom clip=id==0 ? XA_CLIPBOARD(TScreenX11::disp) : XA_PRIMARY;

 // First create a copy, in X11 the clipboard is held by the application
 if (buffer)
    delete[] buffer;
 length=len;
 buffer=new char[length+1];
 memcpy(buffer,b,len);
 buffer[len]=0;
 //printf("Copiando: `%s' %d\n",buffer,length);
 XSetSelectionOwner(TScreenX11::disp,clip,TScreenX11::mainWin,CurrentTime);
 XFlush(TScreenX11::disp);
 if (XGetSelectionOwner(TScreenX11::disp,clip)==TScreenX11::mainWin)
    return 1;
 TVOSClipboard::error=x11clipAnother;
 // The rest is done by TScreenX11
 return 0;
}

/**[txh]********************************************************************

  Description:
  Returns a newly allocated buffer containing the contents of the indicated
clipboard. @x{copy}.@*
  The buffer should be deallocated with delete[]. The string is NULL
terminated because we ensure it.@*
  The returned length doesn't include the EOL.
  
  Return: NULL if error, a new buffer if ok.
  
***************************************************************************/

char *TVX11Clipboard::paste(int id, unsigned &lenRet)
{
 if (id>1) return NULL;
 Atom clip=id==0 ? XA_CLIPBOARD(TScreenX11::disp) : XA_PRIMARY;

 Window owner;
 int format, result;
 unsigned long len, bytes, dummy;
 unsigned char *data;

 owner=XGetSelectionOwner(TScreenX11::disp,clip);
 if (owner==None)
   {
    TVOSClipboard::error=x11clipNoSelection;
    return NULL;
   }
 // What a hell should I use as property here? I use XA_STRING because it was
 // used by the example. BTW the example failed with Eterm.
 XConvertSelection(TScreenX11::disp,clip,XA_STRING,XA_STRING,TScreenX11::mainWin,
                   CurrentTime);
 XFlush(TScreenX11::disp);
 waiting=1;
 while (waiting)
   TScreenX11::ProcessGenericEvents();

 if (property!=XA_STRING)
   {
    TVOSClipboard::error=x11clipWrongType;
    return NULL;
   }
 // Check the size
 Atom type;
 XGetWindowProperty(TScreenX11::disp,TScreenX11::mainWin,XA_STRING,0,0,0,
                    AnyPropertyType,&type,&format,&len,&bytes,&data);
 if (bytes<=0)
   {
    TVOSClipboard::error=x11clipNoData;
    return NULL;
   }
 result=XGetWindowProperty(TScreenX11::disp,TScreenX11::mainWin,XA_STRING,
                           0,bytes,0,AnyPropertyType,&type,&format,&len,
                           &dummy,&data);
 if (result!=Success)
   {
    XFree(data);
    TVOSClipboard::error=x11clipX11Error;
    return NULL;
   }
 char *ret=new char[bytes+1];
 memcpy(ret,data,bytes);
 ret[bytes]=0;
 XFree(data);
 lenRet=bytes;
 //printf("Recibiendo: `%s' %ld\n",ret,bytes);

 return ret;
}

void TVX11Clipboard::destroy()
{
 if (buffer)
   {
    delete[] buffer;
    buffer=0;
   }
}

/*****************************************************************************
  Fonts routines
*****************************************************************************/

int TScreenX11::GetFontGeometry(unsigned &w, unsigned &h)
{
 w=fontW;
 h=fontH;
 return 1;
}

int TScreenX11::GetFontGeometryRange(unsigned &wmin, unsigned &hmin,
                                     unsigned &wmax, unsigned &hmax)
{
 wmin=wmax=hmin=8;
 hmax=20;
 return 1;
}

int TScreenX11::SetFont(int which, TScreenFont256 *font, int fontCP, int appCP)
{
 // Check if that's just a call to disable the secondary font
 if (which && !font)
   {
    DestroyXImageFont(which);
    return 1;
   }

 if (font->w!=8 || font->h<8 || font->h>20)
    return 0;

 if (font->w!=fontW || font->h!=fontH)
   {
    if (which) // The secondary font must be of the same size as the primary
       return 0;
    unsigned start=100*cShapeFrom/fontH;
    unsigned end  =100*cShapeTo/fontH;
    fontW=font->w;
    fontH=font->h;
    /* Change the cursor shape */
    SetCursorShape(start,end);
    /* Inform the WM about this change*/
    sizeHints->width_inc =fontW;
    sizeHints->height_inc=fontH;
    XSetWMNormalHints(disp,mainWin,sizeHints);
    /* Change the size */
    XResizeWindow(disp,mainWin,maxX*fontW,maxY*fontH);
   }
 DestroyXImageFont(which);
 CreateXImageFont(which,font->data,font->w,font->h);
 if (which && fontCP!=-1)
   {
    if (appCP==-1)
       TVCodePage::SetScreenCodePage(fontCP);
    else
       TVCodePage::SetCodePage(appCP,fontCP);
   }
 FullRedraw();
 return 1;
}

void TScreenX11::RestoreFonts()
{
 TScreenFont256 font={8,16,DefaultFont};
 SetFont(0,&font,TVCodePage::ISOLatin1Linux,TVCodePage::ISOLatin1Linux);
 disableSecondaryFont();
}
#else

#include <tv/x11/screen.h>
#include <tv/x11/key.h>
#include <tv/x11/mouse.h>

#endif // defined(TVOS_UNIX) && defined(HAVE_X11)

